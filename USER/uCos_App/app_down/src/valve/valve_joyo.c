/*
  ********************************************************************************************************
  * @file    valve_joyo.c
  * @author  zjjin
  * @version V0.0.0
  * @date    04-20-2015
  * @brief   
  ********************************************************************************************************
  * @attention
  *		±±æ©æ©‘¥–≠“È∑ßøÿ∆˜π¶ƒ‹ µœ÷œ‡πÿ¥˙¬Î°£
  *
  ********************************************************************************************************
  */  

//#include <includes.h>

#include "Valve.h"  
#include "valve_joyo.h"


#define HEX_TO_BCD(x) ((x/0x0A)*0x10+(x%0x0A))
#define BCD_TO_HEX(x) ((x/0x10)*0x0A+(x%0x10))





/*
  ********************************************************************************************************
  * ∫Ø ˝√˚≥∆: uint8 ValveContron_Elsonic(MeterFileType *p_mf,uint8 functype,uint8 *p_DataIn,uint8 *p_databuf,uint8 *p_datalenback)
  
  * Àµ    √˜£∫±±æ©æ©‘¥ ∑ßøÿ∆˜øÿ÷∆∫Ø ˝£¨‘⁄¥À∫Ø ˝÷– µœ÷“⁄¡÷∑ßøÿ≤ªÕ¨øÿ÷∆°£
  *					
  *  ‰»Î≤Œ ˝£∫ 
  				MeterFileType *p_mf   ±Ì≤Œ ˝£¨∫¨”–∑ßøÿ–≠“È∞Ê±æ°¢∑ßøÿµÿ÷∑µ»–≈œ¢°£
  				uint8 functype  ∂‘∑ßΩ¯–– ≤√¥—˘µƒøÿ÷∆£¨±»»Á∂¡–≈œ¢°¢…Ë÷√…œœ¬œﬁŒ¬∂»µ»°£
				uint8 *p_datain   ‰»Î∫Ø ˝ø…ƒ‹“™ π”√µƒ ˝æ›°£
  				uint8 *p_databuf    ¥”∑ßøÿ÷–∂¡…œ¿¥µƒ ˝æ›¥Ê¥¢÷∏’Î°£
  				uint8 p_datalenback  ¥”∑ßøÿ÷–∂¡…œ¿¥µƒ ˝æ›≥§∂»°£
  *  ‰≥ˆ≤Œ ˝:
  				÷¥–– «∑Ò≥…π¶°£
  ********************************************************************************************************
  */

uint8 ValveContron_Joyo(MeterFileType *p_mf,uint8 functype,uint8 *p_DataIn,uint8 *p_databuf,uint8 *p_datalenback)
{
	uint8 Err = 0;
	uint8 lu8dataframe[100] = {0};
	uint8 lu8datalen = 0;
	uint8 lu8databuf[20] = {0xee};
	uint8 lu8datalenback = 0;
	uint8 i =0;
	uint8 lu8tmp = 0;
	

	
	switch(functype){
		case ReadVALVE_All:{						
			Create_JOYOVave_ReadInfo_Frame(p_mf,lu8dataframe, &lu8datalen);//◊ÈΩ®ªÒ»°∑ß√≈ ˝æ›√¸¡Ó÷°
			Err = JOYO_ReadData_Communicate(lu8dataframe, &lu8datalen);
			
			if(Err == NO_ERR){	  
				lu8databuf[i++] = 0x00;  //–° ˝ŒªπÃ∂®Œ™0.
				lu8datalenback++;
				lu8databuf[i++] = HEX_TO_BCD(lu8dataframe[9]);
				lu8datalenback++;
				lu8databuf[i++] = 0x00;  //∑˚∫≈Œª
				lu8datalenback++;
			
				lu8tmp = lu8dataframe[4];
				if(lu8tmp & 0x04)	   //»Áπ˚bit2=1±Ì æ∑ß√≈ø™◊¥Ã¨£¨0πÿ◊¥Ã¨°£
					lu8databuf[i++] = 0x55;  // »´ø™
				else
					lu8databuf[i++] = 0x99;  //»´πÿ°£
								
				lu8datalenback++;
				
				//begin:∑ßøÿ◊¥Ã¨Œª◊÷Ω⁄¥¶¿Ì°£
				lu8databuf[4] = 0; //œ»Ω´◊¥Ã¨◊÷Ω⁄≥ı ºªØŒ™0 °£
				lu8tmp = lu8dataframe[3];
				if((lu8tmp & 0x10) == 0)  //√Ê∞Âø™πÿ,bit4=1ø™ª˙£¨0πÿª˙°£
					lu8databuf[4] |= 0x02;

				if(lu8tmp & 0x0c)          //∑ß√≈ «∑ÒÀ¯∂®£¨bit2bit3=01«ø÷∆ø™∆Ù£¨10«ø÷∆πÿ±’°£
					lu8databuf[4] |= 0x08;	//¥À¥¶÷ª≈–∂œ «∑ÒÀ¯∂®£¨Ω·∫œ∑ß√≈◊¥Ã¨≈–∂œ «À¯∂®ø™∆Ùorπÿ±’°£

				lu8tmp = lu8dataframe[4];
				if(lu8tmp & 0x02)         //√Ê∞Â «∑ÒÀ¯∂®£¨bit1=1À¯∂®°£
					lu8databuf[4] |= 0x04;


				//end:∑ßøÿ◊¥Ã¨Œª◊÷Ω⁄¥¶¿Ì°

				i++;
				lu8datalenback++;
				lu8databuf[i++] = 0x00;  //‘§¡Ù°£
				lu8datalenback++;
							
			}				
			else{
				memset(lu8databuf, 0xee, 6);
				lu8datalenback += 6;								
				debug_err(gDebugModule[TASKDOWN_MODULE],"%s %d Read Valve state failed!\r\n",__FUNCTION__,__LINE__);
			}

			memcpy(p_databuf,lu8databuf,lu8datalenback);
			*p_datalenback = lu8datalenback;
			
			break;
		}

		case SETHEAT_DISPLAY:{

			break;
		}

		case SETHEAT_VALUE:{

			break;
		}

		case SETROOM_TEMP:{
			Create_JOYOVave_SetRoomTemp_Frame(p_mf,p_DataIn,lu8dataframe, &lu8datalen);
			Err = JOYO_ReadData_Communicate(lu8dataframe, &lu8datalen);
			
			if(Err == NO_ERR){
					debug_info(gDebugModule[TASKDOWN_MODULE],"%s Set indoor given temperature ok ",__FUNCTION__);
				}
			else{
					debug_err(gDebugModule[TASKDOWN_MODULE],"%s Set indoor given temperature failed ",__FUNCTION__);
			}
			
			memcpy(p_databuf,lu8dataframe,lu8datalen);
			*p_datalenback = lu8datalen;


			break;
		}

		case SETTEMP_RANGE:{
			Create_JOYOVave_SetRoomTempRange_Frame(p_mf,p_DataIn,lu8dataframe, &lu8datalen);
			Err = JOYO_ReadData_Communicate(lu8dataframe, &lu8datalen);
			
			if(Err == NO_ERR)	{
					debug_info(gDebugModule[TASKDOWN_MODULE],"%s Set indoor given temperature ok ",__FUNCTION__);
				}
			else{
					debug_err(gDebugModule[TASKDOWN_MODULE],"%s Set indoor given temperature failed ",__FUNCTION__);
			}

			memcpy(p_databuf,lu8dataframe,lu8datalen);
			*p_datalenback = lu8datalen;

			break;
		}

		case SETVALVE_STATUS:{
			Create_JOYOVave_SetValve_Frame(p_mf,p_DataIn,lu8dataframe, &lu8datalen);
			Err = JOYO_ReadData_Communicate(lu8dataframe, &lu8datalen);

			memcpy(p_databuf,lu8dataframe,lu8datalen);
			*p_datalenback = lu8datalen;

			break;
		}

		default:
			break;
	}



	return Err;
}

/*
  ******************************************************************************
  * ∫Ø ˝√˚≥∆£∫Create_JOYOVave_SetInfo_Frame(DELU_Protocol *pData, uint8 *pSendFrame, uint8 *plenFrame)
  * Àµ    √˜£∫¥À∫Ø ˝”√”⁄∂¡»°æ©‘¥∑ßøÿ∆˜◊¥Ã¨–≈œ¢°£
  * ≤Œ     ˝£∫ 
  ******************************************************************************
  */
void Create_JOYOVave_ReadInfo_Frame(MeterFileType *p_mf, uint8 *pSendFrame, uint8 *plenFrame)
{
		uint8 setInform[8]={0xa0,0x10,0x00,0x00,0x00,0x00,0x00,0x15};
//		uint8 templen	= 0x00;
		uint8 cs		= 0x00;
		uint8 *pTemp;
//		uint16 lenFrame = 0x00;
//		uint16 CheckLen = 0x00;
		uint8 i =0;
		uint8 lu8valveaddr[7] = {0x00};
//		uint16 lu16valveaddr =0;
			
		LOG_assert_param(p_mf == NULL);
		LOG_assert_param(pSendFrame == NULL);
		LOG_assert_param(plenFrame == NULL);
			
		pTemp = pSendFrame;
		
		memcpy(lu8valveaddr, &p_mf->ValveAddr[0], 7);				
		//for(i=0;i<7;i++){
		//	lu8valveaddr[i] = BCD_TO_HEX(lu8valveaddr[i]);
		//}
		//lu16valveaddr = lu8valveaddr[0] + lu8valveaddr[1]*100;
			
		//setInform[1] = lu16valveaddr & 0x00ff;
		//setInform[2] = (lu16valveaddr>>8) & 0x00ff;
		setInform[1] = lu8valveaddr[0];
		setInform[2] = lu8valveaddr[1];
		
		cs = 0;
		for(i=0;i<7;i++){
			cs += setInform[i];
		}
			cs ^= 0xA5;
			setInform[7] = cs;
		
		
		memcpy(pTemp, &setInform[0], 8);
		*plenFrame = 8;
			
		
}


/*
  ******************************************************************************
  * ∫Ø ˝√˚≥∆£∫Create_JOYOVave_SetRoomTemp_Frame(DELU_Protocol *pData, uint8 *pSendFrame, uint8 *plenFrame)
  * Àµ    √˜£∫¥À∫Ø ˝”√”⁄…Ë÷√ “ƒ⁄Œ¬∂»°£
  * ≤Œ     ˝£∫ 
  ******************************************************************************
  */
void Create_JOYOVave_SetRoomTemp_Frame(MeterFileType *p_mf,uint8 *p_DataIn, uint8 *pSendFrame, uint8 *plenFrame)
{
		uint8 setInform[8]={0xa9,0x10,0x00,0x00,0x00,0x00,0x20,0x7b};
//		uint8 templen	= 0x00;
		uint8 cs		= 0x00;
		uint8 *pTemp;
//		uint16 lenFrame = 0x00;
//		uint16 CheckLen = 0x00;
		uint8 i =0;
		uint8 lu8valveaddr[7] = {0x00};
//		uint16 lu16valveaddr =0;
//		uint8 lu8currentheat[4] = {0x00};
//		uint32 lu32currentheat =0;
			
		LOG_assert_param(p_mf == NULL);
		LOG_assert_param(pSendFrame == NULL);
		LOG_assert_param(plenFrame == NULL);
			
		pTemp = pSendFrame;
		
		memcpy(lu8valveaddr, &p_mf->MeterAddr[0], 7);				
		//for(i=0;i<7;i++){
		//	lu8valveaddr[i] = BCD_TO_HEX(lu8valveaddr[i]);
		//}
		//lu16valveaddr = lu8valveaddr[0] + lu8valveaddr[1]*100;
			
		//setInform[1] = lu16valveaddr & 0x00ff;
		//setInform[2] = (lu16valveaddr>>8) & 0x00ff;

		setInform[1] = lu8valveaddr[0];
		setInform[2] = lu8valveaddr[1];


		setInform[6] = BCD_TO_HEX(*(p_DataIn+1));  //…Ë∂®Œ¬∂»
		if(setInform[6] < 5)	 //Œ¬∂»…Ë∂®∑∂Œß5-35°Ê°£
			setInform[6] = 5;
		if(setInform[6] > 30)
			setInform[6] = 30;
		
		cs = 0;
		for(i=0;i<7;i++){
			cs += setInform[i];
		}
			cs ^= 0xA5;
			setInform[7] = cs;
		
		
		memcpy(pTemp, &setInform[0], 8);
		*plenFrame = 8;
			
		
}


/*
  ******************************************************************************
  * ∫Ø ˝√˚≥∆£∫Create_JOYOVave_SetRoomTempRange_Frame(DELU_Protocol *pData, uint8 *pSendFrame, uint8 *plenFrame)
  * Àµ    √˜£∫¥À∫Ø ˝”√”⁄…Ë÷√ “ƒ⁄Œ¬∂»…œœ¬œﬁ°£
  * ≤Œ     ˝£∫ 
  ******************************************************************************
  */
void Create_JOYOVave_SetRoomTempRange_Frame(MeterFileType *p_mf,uint8 *p_DataIn, uint8 *pSendFrame, uint8 *plenFrame)
{
		uint8 setInform[8]={0xa6,0x10,0x00,0x00,0x0a,0x20,0x00,0x7b};
//		uint8 templen	= 0x00;
		uint8 cs		= 0x00;
		uint8 *pTemp;
//		uint16 lenFrame = 0x00;
//		uint16 CheckLen = 0x00;
		uint8 i =0;
		uint8 lu8valveaddr[7] = {0x00};
//		uint16 lu16valveaddr =0;
//		uint8 lu8currentheat[4] = {0x00};
//		uint32 lu32currentheat =0;
			
		LOG_assert_param(p_mf == NULL);
		LOG_assert_param(pSendFrame == NULL);
		LOG_assert_param(plenFrame == NULL);
			
		pTemp = pSendFrame;
		
		memcpy(lu8valveaddr, &p_mf->MeterAddr[0], 7);				
		//for(i=0;i<7;i++){
		//	lu8valveaddr[i] = BCD_TO_HEX(lu8valveaddr[i]);
		//}
		//lu16valveaddr = lu8valveaddr[0] + lu8valveaddr[1]*100;
			
		//setInform[1] = lu16valveaddr & 0x00ff;
		//setInform[2] = (lu16valveaddr>>8) & 0x00ff;

		setInform[1] = lu8valveaddr[0];
		setInform[2] = lu8valveaddr[1];


		setInform[5] = BCD_TO_HEX(*(p_DataIn+1));  //…Ë∂®Œ¬∂»…œœﬁ÷µ°£
		if(setInform[5] < 35)    //…œœﬁ∑∂Œß35-70°Ê°£
			setInform[5] = 35;
		if(setInform[5] > 70)   
			setInform[5] = 70;

		setInform[4] = BCD_TO_HEX(*(p_DataIn+4));  //…Ë∂®Œ¬∂»œ¬œﬁ÷µ°£
		if(setInform[4] < 5)    //…œœﬁ∑∂Œß5-10°Ê°£
			setInform[4] = 5;
		if(setInform[4] > 10)   
			setInform[4] = 10;

		cs = 0;
		for(i=0;i<7;i++){
			cs += setInform[i];
		}
			cs ^= 0xA5;
			setInform[7] = cs;
		
		
		memcpy(pTemp, &setInform[0], 8);
		*plenFrame = 8;
			
		
}

		

/*
  ******************************************************************************
  * ∫Ø ˝√˚≥∆£∫Create_JOYOVave_SetValve_Frame(DELU_Protocol *pData, uint8 valvestate,uint8 *pSendFrame, uint8 *plenFrame)
  * Àµ    √˜£∫¥À∫Ø ˝”√”⁄«ø÷∆ø™πÿ∑ß°£
  * ≤Œ     ˝£∫ 
  ******************************************************************************
  */
void Create_JOYOVave_SetValve_Frame(MeterFileType *p_mf, uint8 *p_DataIn,uint8 *pSendFrame, uint8 *plenFrame)
{
		uint8 setInform[8]={0xa3,0x10,0x00,0x00,0x00,0x00,0x00,0x7b};
//		uint8 templen	= 0x00;
		uint8 cs		= 0x00;
		uint8 *pTemp;
//		uint16 lenFrame = 0x00;
//		uint16 CheckLen = 0x00;
		uint8 i =0;
		uint8 lu8valveaddr[7] = {0x00};
//		uint16 lu16valveaddr =0;
//		uint8 lu8currentheat[4] = {0x00};
//		uint32 lu32currentheat =0;
			
		LOG_assert_param(p_mf == NULL);
		LOG_assert_param(pSendFrame == NULL);
		LOG_assert_param(plenFrame == NULL);
			
		pTemp = pSendFrame;
		
		memcpy(lu8valveaddr, &p_mf->MeterAddr[0], 7);				
		//for(i=0;i<7;i++){
		//	lu8valveaddr[i] = BCD_TO_HEX(lu8valveaddr[i]);
		//}
		//lu16valveaddr = lu8valveaddr[0] + lu8valveaddr[1]*100;
			
		//setInform[1] = lu16valveaddr & 0x00ff;
		//setInform[2] = (lu16valveaddr>>8) & 0x00ff;

		setInform[1] = lu8valveaddr[0];
		setInform[2] = lu8valveaddr[1];

		if(*p_DataIn == 0x99)  //»´πÿ
			setInform[3] = 0x02;
		else if(*p_DataIn == 0x55)	//»´ø™
			setInform[3] = 0x04;
		else
			setInform[3] = 0x00;

    	cs = 0;
		for(i=0;i<7;i++){
			cs += setInform[i];
		}
			cs ^= 0xA5;
			setInform[7] = cs;
		
		
		memcpy(pTemp, &setInform[0], 8);
		*plenFrame = 8;
			
		
}




uint8 JOYO_ReadData_Communicate(uint8 *DataFrame, uint8 *DataLen)
{

	 uint8 err;
	 uint8 RetryTimes	  = 0x02;
//	 uint8 data=0;
	 uint8 dev = DOWN_COMM_DEV_MBUS;
     uint8 i=0; 
	 uint8 len=0;
	  
	 uint8 DataBuf[METER_FRAME_LEN_MAX];
     LOG_assert_param(DataFrame == NULL);
	 LOG_assert_param(DataLen == NULL);
	
	for(i=0;i<RetryTimes;i++){
		DuQueueFlush(dev);				  //«Âø’ª∫≥Â«¯	  
		DuSend(dev, (uint8*)DataFrame,  *DataLen);
		
		//OSTimeDly(OS_TICKS_PER_SEC/10);
		
		err = Receive_Read_ElsonicParamFrame(dev, DataBuf, 0, &len);

		if(err==NO_ERR){
			 memcpy(DataFrame, &DataBuf[0], len);
			 *DataLen = len;
			 return NO_ERR;
		}
		else{
			OSTimeDlyHMSM(0,0,0,500);	 //»Áπ˚≤ª≥…π¶‘Ú≤π≥≠£¨º‰∏Ù500ms°£
		}
		  
	}           
         
     return 1;
}



uint8 Receive_Read_JOYOParamFrame(uint8 dev, uint8 *buf, uint16 Out_Time, uint8 *datalen)
{
	uint8 data=0;
	uint8 i=0;
	uint8 readinfom[32]={0};
//	uint8 len = 0;
//	uint8 len1 = 0;
	uint8 Cs=0;
	
    i = 10;

	while(i--){													//’“÷°Õ∑
			if(DuGetch(dev, &data, 2*OS_TICKS_PER_SEC))
				{return 1;}
			
			if(data == 0x50) //’“µΩ÷°Õ∑	
				{break; }
			
	}

	readinfom[0] = 0x50;
	Cs += readinfom[0];

	for(i=1;i<11;i++){
		if(DuGetch(dev, &data, 2*OS_TICKS_PER_SEC)){
			return 2;
		}
		readinfom[i] = data;
		Cs	+= data;
	}

	Cs ^= 0xa5;

	if(DuGetch(dev, &data, 2*OS_TICKS_PER_SEC)){
			return 3;
	}
	readinfom[11] = data;

	if(Cs != readinfom[11]){
			return 4;
	}

	*datalen = 12;
	memcpy(buf, &readinfom[0], *datalen);

	return 0;
	
		
}	

