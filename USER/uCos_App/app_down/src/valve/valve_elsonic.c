/*
  ********************************************************************************************************
  * @file    valve_elsonic.c
  * @author  zjjin
  * @version V0.0.0
  * @date    04-15-2015
  * @brief   
  ********************************************************************************************************
  * @attention
  *		“⁄¡÷–≠“È∑ßøÿ∆˜π¶ƒ‹ µœ÷œ‡πÿ¥˙¬Î°£
  *
  ********************************************************************************************************
  */  

//#include <includes.h>

#include "Valve.h"  
#include "valve_elsonic.h"


#define HEX_TO_BCD(x) ((x/0x0A)*0x10+(x%0x0A))
#define BCD_TO_HEX(x) ((x/0x10)*0x0A+(x%0x10))



/*
  ********************************************************************************************************
  * ∫Ø ˝√˚≥∆: uint8 ValveContron_Elsonic(MeterFileType *p_mf,uint8 functype,uint8 *p_DataIn,uint8 *p_databuf,uint8 *p_datalenback)
  
  * Àµ    √˜£∫“⁄¡÷ ∑ßøÿ∆˜øÿ÷∆∫Ø ˝£¨‘⁄¥À∫Ø ˝÷– µœ÷“⁄¡÷∑ßøÿ≤ªÕ¨øÿ÷∆°£
  *					
  *  ‰»Î≤Œ ˝£∫ 
  				MeterFileType *p_mf   ±Ì≤Œ ˝£¨∫¨”–∑ßøÿ–≠“È∞Ê±æ°¢∑ßøÿµÿ÷∑µ»–≈œ¢°£
  				uint8 functype  ∂‘∑ßΩ¯–– ≤√¥—˘µƒøÿ÷∆£¨±»»Á∂¡–≈œ¢°¢…Ë÷√…œœ¬œﬁŒ¬∂»µ»°£
				uint8 *p_datain   ‰»Î∫Ø ˝ø…ƒ‹“™ π”√µƒ ˝æ›°£
  				uint8 *p_databuf    ¥”∑ßøÿ÷–∂¡…œ¿¥µƒ ˝æ›¥Ê¥¢÷∏’Î°£
  				uint8 p_datalenback  ¥”∑ßøÿ÷–∂¡…œ¿¥µƒ ˝æ›≥§∂»°£
  *  ‰≥ˆ≤Œ ˝:
  				÷¥–– «∑Ò≥…π¶°£
  ********************************************************************************************************
  */

uint8 ValveContron_Elsonic(MeterFileType *p_mf,uint8 functype,uint8 *p_DataIn,uint8 *p_databuf,uint8 *p_datalenback)
{
	uint8 Err = 0;
	uint8 lu8dataframe[100] = {0};
	uint8 lu8datalen = 0;
	uint8 lu8databuf[20] = {0xee};
	uint8 lu8datalenback = 0;
	uint8 i =0;
	int8 l8tmp = 0;
	uint8 lu8tmp = 0;
	

	
	switch(functype){
		case ReadVALVE_All:{						
			Create_ElsonicVave_ReadInfo_Frame(p_mf,lu8dataframe, &lu8datalen);//◊ÈΩ®ªÒ»°∑ß√≈ ˝æ›√¸¡Ó÷°
			Err = Elsonic_ReadData_Communicate(lu8dataframe, &lu8datalen);
			
			if(Err == NO_ERR){	  
				l8tmp = (int8)lu8dataframe[4];  //∑øº‰Œ¬∂»+≤π≥•Œ¬∂»°£
				l8tmp += lu8dataframe[8];
				lu8tmp = (uint8)l8tmp;
				lu8databuf[i++] = 0x00;  //–° ˝ŒªπÃ∂®Œ™0.
				lu8datalenback++;
				lu8databuf[i++] = HEX_TO_BCD(lu8tmp);
				lu8datalenback++;
				lu8databuf[i++] = 0x00;  //∑˚∫≈Œª
				lu8datalenback++;
			
				lu8tmp = lu8dataframe[7];
				if(lu8tmp & 0x01)	   //»Áπ˚bit0=1±Ì æ∑ß√≈ø™◊¥Ã¨£¨0πÿ◊¥Ã¨°£
					lu8databuf[i++] = 0x55;  // »´ø™
				else
					lu8databuf[i++] = 0x99;  //»´πÿ°£
								
				lu8datalenback++;
				
				//begin:∑ßøÿ◊¥Ã¨Œª◊÷Ω⁄¥¶¿Ì°£
				lu8databuf[4] = 0; //œ»Ω´◊¥Ã¨◊÷Ω⁄≥ı ºªØŒ™0 °£
				lu8tmp = lu8dataframe[7];
				if(lu8tmp & 0x02)  //Œﬁœﬂ“Ï≥£°£
					lu8databuf[4] |= 0x01;

				lu8tmp = lu8dataframe[3];
				if((lu8tmp & 0x01) == 0)  //√Ê∞Âø™πÿ
					lu8databuf[4] |= 0x02;

				if(lu8tmp & 0x04)  //√Ê∞ÂÀ¯∂® «∑Ò°£
					lu8databuf[4] |= 0x04;

				if(lu8tmp & 0x02)  //∑ß√≈ «∑ÒÀ¯∂®°£
					lu8databuf[4] |= 0x08;
				if(lu8tmp & 0x80)  //∑ß√≈ «∑ÒÀ¯∂®°£
					lu8databuf[4] |= 0x08;
				//end:∑ßøÿ◊¥Ã¨Œª◊÷Ω⁄¥¶¿Ì°

				i++;
				lu8datalenback++;
				lu8databuf[i++] = 0x00;  //‘§¡Ù°£
				lu8datalenback++;
							
			}				
			else{
				memset(lu8databuf, 0xee, 6);
				lu8datalenback += 6;								
				debug_err(gDebugModule[TASKDOWN_MODULE],"%s %d Read Valve state failed!\r\n",__FUNCTION__,__LINE__);
			}

			memcpy(p_databuf,lu8databuf,lu8datalenback);
			*p_datalenback = lu8datalenback;
			
			break;
		}

		case SETHEAT_DISPLAY:{
			Create_ElsonicVave_SetInfo_Frame(p_mf,lu8dataframe, &lu8datalen);	//…Ë÷√«Î”√»»¡øœ‘ æ°£		  
			Err = Elsonic_ReadData_Communicate(lu8dataframe, &lu8datalen);
			if(Err != NO_ERR)  {
				debugX(LOG_LEVEL_ERROR,"%s %d Send HeatMeter data  to valve  failed!\r\n",__FUNCTION__,__LINE__);
			}

			memcpy(p_databuf,lu8dataframe,lu8datalen);
			*p_datalenback = lu8datalen;

			break;
		}

		case SETHEAT_VALUE:{
			Create_ElsonicVave_SetHeat_Frame(p_mf,p_DataIn,lu8dataframe, &lu8datalen);
			Err = Elsonic_ReadData_Communicate(lu8dataframe, &lu8datalen);
			if(Err == NO_ERR){
				debug_info(gDebugModule[TASKDOWN_MODULE],"%s %d Send HeatMeter data  to valve ok",__FUNCTION__,__LINE__);
			}
			else  {
				debugX(LOG_LEVEL_ERROR,"%s %d Send HeatMeter data  to valve  failed!\r\n",__FUNCTION__,__LINE__);
			}

			memcpy(p_databuf,lu8dataframe,lu8datalen);
			*p_datalenback = lu8datalen;

			break;
		}

		case SETROOM_TEMP:{
			Create_ElsonicVave_SetRoomTemp_Frame(p_mf,p_DataIn,lu8dataframe, &lu8datalen);
			Err = Elsonic_ReadData_Communicate(lu8dataframe, &lu8datalen);
			
			if(Err == NO_ERR){
					debug_info(gDebugModule[TASKDOWN_MODULE],"%s Set indoor given temperature ok ",__FUNCTION__);
				}
			else{
					debug_err(gDebugModule[TASKDOWN_MODULE],"%s Set indoor given temperature failed ",__FUNCTION__);
			}
			
			memcpy(p_databuf,lu8dataframe,lu8datalen);
			*p_datalenback = lu8datalen;


			break;
		}

		case SETTEMP_RANGE:{
			Create_ElsonicVave_SetRoomTempRange_Frame(p_mf,p_DataIn,lu8dataframe, &lu8datalen);
			Err = Elsonic_ReadData_Communicate(lu8dataframe, &lu8datalen);
			
			if(Err == NO_ERR)	{
					debug_info(gDebugModule[TASKDOWN_MODULE],"%s Set indoor given temperature ok ",__FUNCTION__);
				}
			else{
					debug_err(gDebugModule[TASKDOWN_MODULE],"%s Set indoor given temperature failed ",__FUNCTION__);
			}

			memcpy(p_databuf,lu8dataframe,lu8datalen);
			*p_datalenback = lu8datalen;

			break;
		}

		case SETVALVE_STATUS:{
			Create_ElsonicVave_SetValve_Frame(p_mf,p_DataIn,lu8dataframe, &lu8datalen);
			Err = Elsonic_ReadData_Communicate(lu8dataframe, &lu8datalen);

			memcpy(p_databuf,lu8dataframe,lu8datalen);
			*p_datalenback = lu8datalen;

			break;
		}

		case SETVALVE_CONTROLTYPE:{
			if(*(p_DataIn+0) == 0x09){ //“⁄¡÷∑ß÷ª”–÷ÿ–¬ πƒ‹∑ßøÿ∆˜”…Œ¬øÿ√Ê∞Âøÿ÷∆ ±≤≈÷¥––°£
				Create_ElsonicVave_SetValve_Frame(p_mf,p_DataIn,lu8dataframe, &lu8datalen);
				Err = Elsonic_ReadData_Communicate(lu8dataframe, &lu8datalen);

				memcpy(p_databuf,lu8dataframe,lu8datalen);
				*p_datalenback = lu8datalen;
			}

			break;
		}
		

		default:
			break;
	}



	return Err;
}


  
   /*
	 ******************************************************************************
	 * ∫Ø ˝√˚≥∆£∫Create_ElsonicVave_SetInfo_Frame(DELU_Protocol *pData, uint8 *pSendFrame, uint8 *plenFrame)
	 * Àµ	 √˜£∫¥À∫Ø ˝”√”⁄∂¡»°“⁄¡÷∑ßøÿ∆˜◊¥Ã¨–≈œ¢°£
	 * ≤Œ	  ˝£∫ 
	 ******************************************************************************
	 */
   void Create_ElsonicVave_ReadInfo_Frame(MeterFileType *p_mf, uint8 *pSendFrame, uint8 *plenFrame)
   {
		   uint8 setInform[8]={0xa0,0x19,0x0c,0x00,0x00,0x00,0x00,0x7b};
		   uint8 cs 	   = 0x00;
		   uint8 *pTemp;
		   uint8 i =0;
		   uint8 lu8valveaddr[7] = {0x00};
		   //uint16 lu16valveaddr =0;
			   
		   LOG_assert_param(p_mf == NULL);
		   LOG_assert_param(pSendFrame == NULL);
		   LOG_assert_param(plenFrame == NULL);
			   
		   pTemp = pSendFrame;
		   
		   memcpy(lu8valveaddr, &p_mf->ValveAddr[0], 7);			   
		   //for(i=0;i<7;i++){
		   //  lu8valveaddr[i] = BCD_TO_HEX(lu8valveaddr[i]);
		   //}
		   //lu16valveaddr = lu8valveaddr[0] + lu8valveaddr[1]*100;
			   
		   //setInform[1] = lu16valveaddr & 0x00ff;
		   //setInform[2] = (lu16valveaddr>>8) & 0x00ff;
		   setInform[1] = lu8valveaddr[0];
		   setInform[2] = lu8valveaddr[1];
		   
		   cs = 0;
		   for(i=0;i<7;i++){
			   cs += setInform[i];
		   }
			   cs ^= 0xA5;
			   setInform[7] = cs;
		   
		   
		   memcpy(pTemp, &setInform[0], 8);
		   *plenFrame = 8;
			   
		   
   }
   
   
   /*
	 ******************************************************************************
	 * ∫Ø ˝√˚≥∆£∫Create_ElsonicVave_SetInfo_Frame(DELU_Protocol *pData, uint8 *pSendFrame, uint8 *plenFrame)
	 * Àµ	 √˜£∫¥À∫Ø ˝”√”⁄Ω´…Ë÷√“⁄¡÷∑ßøÿ∆˜ πƒ‹»»¡øœ‘ æπ¶ƒ‹°£
	 * ≤Œ	  ˝£∫ 
	 ******************************************************************************
	 */
   void Create_ElsonicVave_SetInfo_Frame(MeterFileType *p_mf, uint8 *pSendFrame, uint8 *plenFrame)
   {
		   uint8 setInform[8]={0xb1,0x19,0x0c,0x08,0x00,0x00,0x00,0x7b};
		   //uint8 templen   = 0x00;
		   uint8 cs 	   = 0x00;
		   uint8 *pTemp;
		   uint8 i =0;
		   uint8 lu8valveaddr[7] = {0x00};
		   //uint16 lu16valveaddr =0;
			   
		   LOG_assert_param(p_mf == NULL);
		   LOG_assert_param(pSendFrame == NULL);
		   LOG_assert_param(plenFrame == NULL);
			   
		   pTemp = pSendFrame;
		   
		   memcpy(lu8valveaddr, &p_mf->ValveAddr[0], 7);		   
		   //for(i=0;i<7;i++){
		   //  lu8valveaddr[i] = BCD_TO_HEX(lu8valveaddr[i]);
		   //}
		   //lu16valveaddr = lu8valveaddr[0] + lu8valveaddr[1]*100;
			   
		   //setInform[1] = lu16valveaddr & 0x00ff;
		   //setInform[2] = (lu16valveaddr>>8) & 0x00ff;
   
   
		   setInform[1] = lu8valveaddr[0];
		   setInform[2] = lu8valveaddr[1];
		   setInform[3] = 0x08; // ∆Ù”√»»¡øœ‘ æπ¶ƒ‹°£
		   
		   cs = 0;
		   for(i=0;i<7;i++){
			   cs += setInform[i];
		   }
			   cs ^= 0xA5;
			   setInform[7] = cs;
		   
		   
		   memcpy(pTemp, &setInform[0], 8);
		   *plenFrame = 8;
			   
		   
   }
  
   
   
   
   /*
	 ******************************************************************************
	 * ∫Ø ˝√˚≥∆£∫Create_ElsonicVave_SetHeat_Frame(DELU_Protocol *pData, uint8 *pSendFrame, uint8 *plenFrame)
	 * Àµ	 √˜£∫¥À∫Ø ˝”√”⁄Ω´»»¡ø÷µ–¥»Î“⁄¡÷∑ßøÿ∆˜°£
	 * ≤Œ	  ˝£∫ 
	 ******************************************************************************
	 */
   void Create_ElsonicVave_SetHeat_Frame(MeterFileType *p_mf,uint8 *p_DataIn, uint8 *pSendFrame, uint8 *plenFrame)
   {
		   uint8 setInform[8]={0xa4,0x19,0x0c,0x08,0x00,0x00,0x00,0x7b};
		   //uint8 templen   = 0x00;
		   uint8 cs 	   = 0x00;
		   uint8 *pTemp;
//		   uint16 lenFrame = 0x00;
//		   uint16 CheckLen = 0x00;
		   uint8 i =0;
		   uint8 lu8valveaddr[7] = {0x00};
//		   uint16 lu16valveaddr =0;
		   uint8 lu8currentheat[4] = {0x00};
//		   uint32 lu32currentheat =0;
			   
		   LOG_assert_param(p_mf == NULL);
		   LOG_assert_param(pSendFrame == NULL);
		   LOG_assert_param(plenFrame == NULL);
			   
		   pTemp = pSendFrame;
		   
		    memcpy(lu8valveaddr, &p_mf->ValveAddr[0], 7);			   
		   //for(i=0;i<7;i++){
		   //  lu8valveaddr[i] = BCD_TO_HEX(lu8valveaddr[i]);
		   //}
		   //lu16valveaddr = lu8valveaddr[0] + lu8valveaddr[1]*100;
			   
		   //setInform[1] = lu16valveaddr & 0x00ff;
		   //setInform[2] = (lu16valveaddr>>8) & 0x00ff;
   
		   setInform[1] = lu8valveaddr[0];
		   setInform[2] = lu8valveaddr[1];
   
		   memcpy(lu8currentheat,p_DataIn, 4);			   //µ±«∞»»¡ø»°≥ˆ°£
		   setInform[3] = lu8currentheat[1];
		   setInform[4] = lu8currentheat[2];
		   setInform[5] = lu8currentheat[3];
		   setInform[6] = 0x00;  
		   
		   cs = 0;
		   for(i=0;i<7;i++){
			   cs += setInform[i];
		   }
			   cs ^= 0xA5;
			   setInform[7] = cs;
		   
		   
		   memcpy(pTemp, &setInform[0], 8);
		   *plenFrame = 8;
			   
		   
   }
   
   /*
	 ******************************************************************************
	 * ∫Ø ˝√˚≥∆£∫Create_ElsonicVave_SetRoomTemp_Frame(DELU_Protocol *pData, uint8 *pSendFrame, uint8 *plenFrame)
	 * Àµ	 √˜£∫¥À∫Ø ˝”√”⁄…Ë÷√ “ƒ⁄Œ¬∂»°£
	 * ≤Œ	  ˝£∫ 
	 ******************************************************************************
	 */
   void Create_ElsonicVave_SetRoomTemp_Frame(MeterFileType *p_mf,uint8 *p_DataIn, uint8 *pSendFrame, uint8 *plenFrame)
   {
		   uint8 setInform[8]={0xa6,0x19,0x0c,0x00,0x00,0x32,0x00,0x7b};
//		   uint8 templen   = 0x00;
		   uint8 cs 	   = 0x00;
		   uint8 *pTemp;
//		   uint16 lenFrame = 0x00;
//		   uint16 CheckLen = 0x00;
		   uint8 i =0;
		   uint8 lu8valveaddr[7] = {0x00};
//		   uint16 lu16valveaddr =0;
//		   uint8 lu8currentheat[4] = {0x00};
//		   uint32 lu32currentheat =0;
			   
		   LOG_assert_param(p_mf == NULL);
		   LOG_assert_param(pSendFrame == NULL);
		   LOG_assert_param(plenFrame == NULL);
			   
		   pTemp = pSendFrame;
		   
		   memcpy(lu8valveaddr, &p_mf->ValveAddr[0], 7);			   
		   //for(i=0;i<7;i++){
		   //  lu8valveaddr[i] = BCD_TO_HEX(lu8valveaddr[i]);
		   //}
		   //lu16valveaddr = lu8valveaddr[0] + lu8valveaddr[1]*100;
			   
		   //setInform[1] = lu16valveaddr & 0x00ff;
		   //setInform[2] = (lu16valveaddr>>8) & 0x00ff;
   
		   setInform[1] = lu8valveaddr[0];
		   setInform[2] = lu8valveaddr[1];
   
   
		   setInform[5] = BCD_TO_HEX(*(p_DataIn + 1));  //…Ë∂®Œ¬∂»,¥À¥¶–Ë“™µ˜’˚’˝»∑∆´¡ø°£
		   if(setInform[5] < 10)	//Œ¬∂»…Ë∂®∑∂Œß10-30°Ê°£
			   setInform[5] = 10;
		   if(setInform[5] > 30)
			   setInform[5] = 30;
		   
		   setInform[5] = 2 * setInform[5]; 	 //  …Ë∂® “ƒ⁄Œ¬∂»£¨…Ë∂®÷µ «Œ¬∂»÷µµƒ2±∂°£
				   
		   cs = 0;
		   for(i=0;i<7;i++){
			   cs += setInform[i];
		   }
			   cs ^= 0xA5;
			   setInform[7] = cs;
		   
		   
		   memcpy(pTemp, &setInform[0], 8);
		   *plenFrame = 8;
			   
		   
   }
   
   /*
	 ******************************************************************************
	 * ∫Ø ˝√˚≥∆£∫Create_ElsonicVave_SetRoomTempRange_Frame(DELU_Protocol *pData, uint8 *pSendFrame, uint8 *plenFrame)
	 * Àµ	 √˜£∫¥À∫Ø ˝”√”⁄…Ë÷√ “ƒ⁄Œ¬∂»…œœ¬œﬁ°£
	 * ≤Œ	  ˝£∫ 
	 ******************************************************************************
	 */
   void Create_ElsonicVave_SetRoomTempRange_Frame(MeterFileType *p_mf,uint8 *p_DataIn, uint8 *pSendFrame, uint8 *plenFrame)
   {
		   uint8 setInform[8]={0xb0,0x19,0x0c,0xa5,0x3c,0xa5,0x26,0x7b};
//		   uint8 templen   = 0x00;
		   uint8 cs 	   = 0x00;
		   uint8 *pTemp;
//		   uint16 lenFrame = 0x00;
//		   uint16 CheckLen = 0x00;
		   uint8 i =0;
		   uint8 lu8valveaddr[7] = {0x00};
//		   uint16 lu16valveaddr =0;
//		   uint8 lu8currentheat[4] = {0x00};
//		   uint32 lu32currentheat =0;
			   
		   LOG_assert_param(p_mf == NULL);
		   LOG_assert_param(pSendFrame == NULL);
		   LOG_assert_param(plenFrame == NULL);
			   
		   pTemp = pSendFrame;
		   
		    memcpy(lu8valveaddr, &p_mf->ValveAddr[0], 7);			   
		   //for(i=0;i<7;i++){
		   //  lu8valveaddr[i] = BCD_TO_HEX(lu8valveaddr[i]);
		   //}
		   //lu16valveaddr = lu8valveaddr[0] + lu8valveaddr[1]*100;
			   
		   //setInform[1] = lu16valveaddr & 0x00ff;
		   //setInform[2] = (lu16valveaddr>>8) & 0x00ff;
   
		   setInform[1] = lu8valveaddr[0];
		   setInform[2] = lu8valveaddr[1];
   
   
		   setInform[4] = BCD_TO_HEX(*(p_DataIn+1));  //…Ë∂®Œ¬∂»…œœﬁ÷µ°£
		   if(setInform[4] < 20)	//…œœﬁ∑∂Œß20-30°Ê°£
			   setInform[4] = 20;
		   if(setInform[4] > 30)	//…œœﬁ∑∂Œß20-30°Ê°£
			   setInform[4] = 30;
   
		   setInform[4] = 2 * setInform[4]; 	 //  …Ë∂®÷µ «Œ¬∂»÷µµƒ2±∂°£
   
		   setInform[6] = BCD_TO_HEX(*(p_DataIn+4));  //…Ë∂®Œ¬∂»œ¬œﬁ÷µ°£
		   if(setInform[6] < 10)	//…œœﬁ∑∂Œß10-19°Ê°£
			   setInform[6] = 10;
		   if(setInform[6] > 19)   
			   setInform[6] = 19;
   
		   setInform[6] = 2 * setInform[6]; 	 //  …Ë∂®÷µ «Œ¬∂»÷µµƒ2±∂°£
			   
		   cs = 0;
		   for(i=0;i<7;i++){
			   cs += setInform[i];
		   }
			   cs ^= 0xA5;
			   setInform[7] = cs;
		   
		   
		   memcpy(pTemp, &setInform[0], 8);
		   *plenFrame = 8;
			   
		   
   }
		   
   
   /*
	 ******************************************************************************
	 * ∫Ø ˝√˚≥∆£∫Create_ElsonicVave_SetValve_Frame(DELU_Protocol *pData, uint8 valvestate,uint8 *pSendFrame, uint8 *plenFrame)
	 * Àµ	 √˜£∫¥À∫Ø ˝”√”⁄«ø÷∆ø™πÿ∑ß°£
	 * ≤Œ	  ˝£∫ 
	 ******************************************************************************
	 */
   void Create_ElsonicVave_SetValve_Frame(MeterFileType *p_mf, uint8 *p_DataIn,uint8 *pSendFrame, uint8 *plenFrame)
   {
		   uint8 setInform[8]={0xa9,0x19,0x0c,0x00,0x00,0x00,0x00,0x7b};
//		   uint8 templen   = 0x00;
		   uint8 cs 	   = 0x00;
		   uint8 *pTemp;
//		   uint16 lenFrame = 0x00;
//		   uint16 CheckLen = 0x00;
		   uint8 i =0;
		   uint8 lu8valveaddr[7] = {0x00};
//		   uint16 lu16valveaddr =0;
//		   uint8 lu8currentheat[4] = {0x00};
//		   uint32 lu32currentheat =0;
			   
		   LOG_assert_param(p_mf == NULL);
		   LOG_assert_param(pSendFrame == NULL);
		   LOG_assert_param(plenFrame == NULL);
			   
		   pTemp = pSendFrame;
		   
		   memcpy(lu8valveaddr, &p_mf->ValveAddr[0], 7);			   
		   //for(i=0;i<7;i++){
		   //  lu8valveaddr[i] = BCD_TO_HEX(lu8valveaddr[i]);
		   //}
		   //lu16valveaddr = lu8valveaddr[0] + lu8valveaddr[1]*100;
			   
		   //setInform[1] = lu16valveaddr & 0x00ff;
		   //setInform[2] = (lu16valveaddr>>8) & 0x00ff;
   
		   setInform[1] = lu8valveaddr[0];
		   setInform[2] = lu8valveaddr[1];
   
		   if(*p_DataIn == 0x99)
			   setInform[3] = 0x80;
		   else if(*p_DataIn == 0x55)
			   setInform[3] = 0x02;
		   else if(*p_DataIn == 0x09)  //∑ß’˝≥£π§◊˜£¨ªπ «”…Œ¬øÿ√Ê∞Âøÿ÷∆°£
		   	 	setInform[3] = 0;
		   else
			   setInform[3] = 0x02;//∆‰À˚“≤»´≤ø¥Úø™∑ß√≈£¨∞≤»´°£
   
		   cs = 0;
		   for(i=0;i<7;i++){
			   cs += setInform[i];
		   }
			   cs ^= 0xA5;
			   setInform[7] = cs;
		   
		   
		   memcpy(pTemp, &setInform[0], 8);
		   *plenFrame = 8;
			   
		   
   }
   
   
   
   uint8 Elsonic_ReadData_Communicate(uint8 *DataFrame, uint8 *DataLen)
   {
   
		uint8 err;
		//uint8 RetryTimes	 = 0x02;
//		uint8 data=0;
		uint8 dev = DOWN_COMM_DEV_MBUS;
//		uint8 i=0; 
		uint8 len=0;
		 
		uint8 DataBuf[50];
		LOG_assert_param(DataFrame == NULL);
		LOG_assert_param(DataLen == NULL);
	   
	   //for(i=0;i<RetryTimes;i++){
		   DuQueueFlush(dev);				 //«Âø’ª∫≥Â«¯	 
		   DuSend(dev, (uint8*)DataFrame,  *DataLen);
		   
		   //OSTimeDly(OS_TICKS_PER_SEC/10);
		   
		   err = Receive_Read_ElsonicParamFrame(dev, DataBuf, 0, &len);
   
		   if(err==NO_ERR){
				memcpy(DataFrame, &DataBuf[0], len);
				*DataLen = len;
				return NO_ERR;
			}
		   	//else{
			//	OSTimeDlyHMSM(0,0,0,500);    //»Áπ˚≤ª≥…π¶‘Ú≤π≥≠£¨º‰∏Ù500ms°£
			//}
			 
	  // }		   
			
		return 1;
   }
   
   
   uint8 Receive_Read_ElsonicParamFrame(uint8 dev, uint8 *buf, uint16 Out_Time, uint8 *datalen)
   {
	   uint8 data=0;
	   uint8 i=0;
	   uint8 readinfom[32]={0};
//	   uint8 len = 0;
//	   uint8 len1 = 0;
	   uint8 Cs=0;
	   
	   i = 10;
   
	   while(i--){												   //’“÷°Õ∑
			   if(DuGetch(dev, &data, 3*OS_TICKS_PER_SEC))
				   {return 1;}
			   
			   if(data == 0x50) //’“µΩ÷°Õ∑ 
				   {break; }
			   
	   }
   
	   readinfom[0] = 0x50;
	   Cs += readinfom[0];
   
	   for(i=1;i<11;i++){
		   if(DuGetch(dev, &data, 3*OS_TICKS_PER_SEC)){
			   return 2;
		   }
		   readinfom[i] = data;
		   Cs  += data;
	   }
   
	   Cs ^= 0xa5;
   
	   if(DuGetch(dev, &data, 3*OS_TICKS_PER_SEC)){
			   return 3;
	   }
	   readinfom[11] = data;
   
	   if(Cs != readinfom[11]){
			   return 4;
	   }
   
	   *datalen = 12;
	   memcpy(buf, &readinfom[0], *datalen);
   
	   return 0;
	   
		   
   }   

